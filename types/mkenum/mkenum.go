// Program mkenum constructs  type enumerations for the optional fields
// that may be requested in Twitter API v2.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"sort"
	"strings"

	"github.com/creachadair/twitter/types"
)

var _ types.Tweet

var outputPath = flag.String("output", "", "Output path (required)")

func main() {
	flag.Parse()
	if *outputPath == "" {
		log.Fatal("You must provide a non-empty -output path")
	}

	var code bytes.Buffer

	// N.B. The comment suppresses golint checks in this file.
	// See: https://golang.org/s/generatedcode
	fmt.Fprintf(&code, "package types\n// Code generated by %[1]s. DO NOT EDIT.\n\n",
		filepath.Base(os.Args[0]))
	generateEnum("Tweet", (*types.Tweet)(nil), &code)
	generateSearchableSlice("Tweet", "ID", &code)
	generateEnum("User", (*types.User)(nil), &code)
	generateSearchableSlice("User", "ID", &code)
	generateEnum("Media", (*types.Media)(nil), &code)
	generateSearchableSlice("Media", "Key", &code)
	generateEnum("Poll", (*types.Poll)(nil), &code)
	generateSearchableSlice("Poll", "ID", &code)
	generateEnum("Place", (*types.Place)(nil), &code)
	generateSearchableSlice("Place", "ID", &code)

	clean, err := format.Source(code.Bytes())
	if err != nil {
		log.Fatalf("Formatting generated code: %v", err)
	}
	if err := os.MkdirAll(filepath.Dir(*outputPath), 0700); err != nil {
		log.Fatalf("Creating output directory: %v", err)
	}
	f, err := os.Create(*outputPath)
	if err != nil {
		log.Fatalf("Creating output file: %v", err)
	}
	_, err = f.Write(clean)
	cerr := f.Close()
	if err != nil {
		log.Fatalf("Writing generated code: %v", err)
	}
	if cerr != nil {
		log.Fatalf("Closing output: %v", err)
	}
}

func generateEnum(base string, v interface{}, w io.Writer) {
	typeName := base + "Fields"
	typeLabel := strings.ToLower(base) + ".fields"

	fmt.Fprintf(w, "// Legal values of the %s enumeration.\n", typeName)
	fmt.Fprintln(w, "const (")
	fmt.Fprintf(w, "\t// %s is the label for optional %s field parameters.\n", typeName, base)
	fmt.Fprintf(w, "\t%s = %q\n\n", typeName, typeLabel)

	fields := fieldKeys(v)

	// Order fields lexicographically by JSON name, for consistency.
	var names []string
	for key := range fields {
		names = append(names, key)
	}
	sort.Strings(names)

	for _, key := range names {
		field := fields[key]
		enumName := base + "_" + field
		fmt.Fprintf(w, "\t%s = %q\n", enumName, key)
	}

	fmt.Fprintln(w, ")")
}

func generateSearchableSlice(base, field string, w io.Writer) {
	typeName := base + "s"
	recvName := strings.ToLower(base[:1]) + "s"
	funcName := fmt.Sprintf("FindBy%s", field)
	paramName := strings.ToLower(field)

	fmt.Fprintf(w, "// %s is a searchable slice of %s values.\n", typeName, base)
	fmt.Fprintf(w, "type %s []*%s\n", typeName, base)
	fmt.Fprintln(w)

	fmt.Fprintf(w, "// %s returns the first %s in %s whose %s matches, or nil.\n",
		funcName, base, recvName, field)
	fmt.Fprintf(w, `func (%[1]s %[2]s) %[4]s(%[5]s string) *%[6]s {
  for _, v := range %[1]s {
    if v.%[3]s == %[5]s {
      return v
    }
  }
  return nil
}
`, recvName, typeName, field, funcName, paramName, base)
}

// fieldKeys returns a map of JSON field keys to the associated struct field
// names, extracted from the struct tags of v, which must be of type *T for
// some struct type T.  This function panics if v's type does not have this
// form.
func fieldKeys(v interface{}) map[string]string {
	typ := reflect.TypeOf(v).Elem() // panics if not a pointer
	if typ.Kind() != reflect.Struct {
		panic("pointer target is not a struct")
	}
	tags := make(map[string]string)
	for i := 0; i < typ.NumField(); i++ {
		next := typ.Field(i)
		if isDefaultField(next.Tag) {
			continue // default fields do not require enumerators
		}

		name, ok := jsonFieldName(next.Tag)
		if ok {
			tags[name] = next.Name
			continue
		}

		// If next is an embedded anonymous struct, visit its subfields.
		if next.Anonymous && next.Type.Kind() == reflect.Struct {
			for j := 0; j < next.Type.NumField(); j++ {
				sub := next.Type.Field(j)
				name, ok := jsonFieldName(sub.Tag)
				if ok {
					tags[name] = sub.Name
				}
			}
		}
	}
	return tags
}

func jsonFieldName(tag reflect.StructTag) (string, bool) {
	val, ok := tag.Lookup("json")
	if ok {
		name := strings.SplitN(val, ",", 2)[0]
		return name, name != "-"
	}
	return "", false
}

func isDefaultField(tag reflect.StructTag) bool {
	for _, s := range strings.Split(tag.Get("twitter"), ",") {
		if s == "default" {
			return true
		}
	}
	return false
}
